非确定型图灵机
如果不加特殊说明，通常所说的图灵机都是确定型图灵机。非确定型图灵机和确定型图灵机的不同之处在于，在计算的每一时刻，根据当前状态和读写头所读的符号，机器存在多种状态转移方案，机器将任意地选择其中一种方案继续运作，直到最后停机为止。具体而言，其状态转移函数为
其中formula_2是状态集合，formula_3是带字母表，formula_4分别表示读写头向左和向右移动；符号formula_5 表示集合formula_6的幂集，即 
例如，设非确定型图灵机formula_8的当前状态为formula_9，当前读写头所读的符号为formula_10，若
则formula_8将"任意地"选择一个formula_13，按其进行操作，然后进入下一步计算。

不确定型图灵机在输入串上的计算步骤可以表示为树状结构，树的不同分支代表每一步的不同可能性。只要有一个分支达到接受状态，就称该图灵机接受该输入串；若达到拒绝状态，则称拒绝。有些分支可能永远无法停止，但只要有一个分支能够达到接受或拒绝状态，我们就说图灵机在该输入串上能够停止。要注意的是，图灵机必须无矛盾，即不能同时接受和拒绝同一个输入串。对于任意一个不确定型图灵机，存在一个与之语言相等的确定型图灵机。证明：因为不确定型图灵机的计算步骤就是树状结构，所以只需游历这棵树就能模拟其计算步骤。一个简单的想法是使用深度优先搜索来游历计算树，但这样不可行，因为有些计算分支可能永远不停止！因此，我们可以使用一种在算法中称为迭代加深搜索的方法来游历计算树。具体证明如下：

对于非确定型机器的表达式8，构造一个确定型机器26如下：显然，若表达式8有某个分支可以停机，则此26也一定会找到该分支并停机。因此得出结论。命题2：如果语言L被非确定型机器8在多项式时间接受，则一定存在P多项式使得语言L被时间复杂度表达式43的确定型机器程序所接受。命题2说明了为什么在证明P = NP之前，所有的NPC问题都只有指数级算法。

