[
    {
        "substitutions": {
            "遍历": "游历",
            "定理": "已知正确的命题或公式",
            "非确定型图灵机": "不确定型图灵机",
            "确定型图灵机": "确定型图灵机",
            "计算过程": "计算步骤",
            "计算树": "计算流程",
            "接受状态": "接受",
            "拒绝状态": "拒绝",
            "非矛盾的": "无矛盾的"
        },
        "simplified_text": "不确定型图灵机在输入串上的计算步骤可以表示为树状结构，树的不同分支代表每一步的不同可能性。只要有一个分支达到接受状态，就称该图灵机接受该输入串；若达到拒绝状态，则称拒绝。有些分支可能永远无法停止，但只要有一个分支能够达到接受或拒绝状态，我们就说图灵机在该输入串上能够停止。要注意的是，图灵机必须无矛盾，即不能同时接受和拒绝同一个输入串。对于任意一个不确定型图灵机，存在一个与之语言相等的确定型图灵机。证明：因为不确定型图灵机的计算步骤就是树状结构，所以只需游历这棵树就能模拟其计算步骤。一个简单的想法是使用深度优先搜索来游历计算树，但这样不可行，因为有些计算分支可能永远不停止！因此，我们可以使用一种在算法中称为迭代加深搜索的方法来游历计算树。具体证明如下：",
        "original": "非确定型图灵机formula_8在输入串formula_15上的计算过程可以表示为一棵树，不同的分支对应着每一步计算的不同的可能性。只要有任意一个分支进入接受状态，则称formula_8接受formula_15；只要有任意一个分支进入拒绝状态，则称formula_8拒绝formula_15；某些分支可能永远无法停机，但只要有一个分支可以进入接受或拒绝状态，我们就说formula_8在输入formula_15上可停机。注意，我们规定formula_8必须是无矛盾的，即它不能有某个分支接受formula_15而同时另一个分支拒绝formula_15，这样有矛盾的非确定型图灵机是不合法的。\n定理：对于任意一个非确定型图灵机formula_8，存在一个确定型图灵机formula_26，使得它们的语言相等，即formula_27。\n证明：因为非确定型图灵机的计算过程就是一棵树，因此我们只需遍历该树就可以模拟其计算过程。一个简单的想法是利用深度优先搜索来遍历formula_8的计算树，但这样行不通，因为formula_8的某些计算分支可能永远不停机！所以我们可以采用一种在算法设计中称为迭代加深搜索的技巧来遍历formula_8的计算树。具体证明如下：",
        "version": 1,
        "chunk_num": 2,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "定理": "命题",
            "公式": "表达式",
            "确定型图灵机": "确定型机器",
            "非确定型图灵机": "非确定型机器",
            "多项式时间内": "多项式时间",
            "多项式P": "P多项式",
            "时间复杂度": "时间复杂",
            "指数时间复杂度算法": "指数级算法"
        },
        "simplified_text": "对于非确定型机器的表达式8，构造一个确定型机器26如下：显然，若表达式8有某个分支可以停机，则此26也一定会找到该分支并停机。因此得出结论。命题2：如果语言L被非确定型机器8在多项式时间接受，则一定存在P多项式使得语言L被时间复杂度表达式43的确定型机器程序所接受。命题2说明了为什么在证明P = NP之前，所有的NPC问题都只有指数级算法。",
        "original": "对于非确定型图灵机formula_8，构造一个确定型图灵机formula_26如下：\n显然，若formula_8有某个分支可以停机，则此formula_26也一定会找到该分支并停机。因此formula_27。\n定理2：如果语言L被非确定型图灵机formula_8在多项式时间内接受，则一定存在多项式P使得语言L被时间复杂度为formula_43的确定型图灵机程序所接受。\n定理2说明了为什么在证明P = NP之前，所有的NPC问题都只有指数时间复杂度算法。",
        "version": 1,
        "chunk_num": 3,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "函数": "数学关系",
            "状态转移函数": "状态转移规则",
            "状态集合": "状态集合",
            "字母表": "字符集",
            "读写头": "读取头",
            "幂集": "所有子集的集合",
            "任意地": "随机地"
        },
        "simplified_text": "非确定型图灵机通常指的是确定型图灵机。它与确定型图灵机不同，计算时机器有多种状态转移选择，会随机选择一种方案继续运行，直到停机。具体来说，它的状态转移规则包括状态集合、字符集，以及读取头左右移动的规则；符号表示字符集的所有子集。例如，如果非确定型图灵机当前状态和读取头所读字符，它会随机选择一个子集进行操作，然后进入下一步计算。",
        "original": "非确定型图灵机如果不加特殊说明，通常所说的图灵机都是确定型图灵机。非确定型图灵机与确定型图灵机不同，因为计算过程中，机器根据当前状态和读写头读取的符号，有多种状态转移选择。机器会随机选择一种方案继续运行，直到停机。具体而言，其状态转移函数formula_2是状态集合，formula_3是字母表，formula_4分别表示读写头向左和向右移动；符号formula_5表示formula_6的幂集。例如，如果非确定型图灵机当前状态为formula_9，读写头所读符号为formula_10，则它将'任意地'选择一个formula_13，按其进行操作，然后进入下一步计算。",
        "version": 2,
        "chunk_num": 1,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "不确定型图灵机": "不确定图灵机",
            "计算步骤": "计算过程",
            "状结构": "状态树",
            "接受状态": "接受状态",
            "拒绝状态": "拒绝状态",
            "输入串": "输入序列",
            "无矛盾": "无冲突",
            "确定型图灵机": "确定图灵机",
            "游历": "遍历",
            "深度优先搜索": "深度优先遍历",
            "迭代加深搜索": "迭代加深搜索方法"
        },
        "simplified_text": "不确定图灵机的计算过程可以表示成状态树。树中的每个分支代表一种计算可能。只要有一个分支达到接受状态，就接受输入序列；达到拒绝状态，则拒绝。图灵机在某输入序列上能停止的条件是，有些分支可能永远无法停止，只要有一个分支进入接受或拒绝状态即可。注意，图灵机必须无冲突，即不能同时接受和拒绝同一个输入序列。对于任意一个不确定图灵机，存在一个与之语言相等的确定图灵机。因为不确定图灵机的计算过程是状态树，所以只需遍历这棵树即可模拟其计算过程。想用深度优先遍历遍历状态树，但这不可行。因为有些计算分支可能永远不会停止！因此，我们可以使用一种在算法中称为迭代加深搜索方法来遍历状态树。具体证明如下：",
        "original": "不确定型图灵机的计算步骤可以表示成状结构。状的每一分支代表一种计算可能性。图灵机只要有一个分支达到接受状态，就接受该输入串；达到拒绝状态，则拒绝。图灵机在某输入串上能停止的条件是，只要有些分支可能永远无法停止，只要有一个分支进入接受或拒绝状态即可。要注意的是，图灵机必须无矛盾，即不能同时接受和拒绝同一个输入串。对于任意一个不确定型图灵机，存在一个与之语言相等的确定型图灵机。因为不确定型图灵机的计算步骤是状结构，所以只需游历这棵状即可模拟其计算步骤。想用深度优先搜索游历计算状，但这不可行。因为有些计算分支可能永远不会停止！因此，我们可以使用一种在算法中称为迭代加深搜索的方法来游历计算状。具体证明如下：",
        "version": 2,
        "chunk_num": 2,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "非确定型机器": "不确定型机器",
            "确定型机器": "确定型机器",
            "可停机的分支": "能停机的分支",
            "多项式时间内": "在多项式时间内",
            "时间复杂度": "时间复杂",
            "指数级算法": "指数算法"
        },
        "simplified_text": "对于不确定型机器的表达式8，构造确定型机器26。如果表达式8有能停机的分支，则26也能找到并停机。因此得出结论。命题2：如果不确定型机器8在多项式时间内接受语言L，则存在P多项式。该多项式使得语言L能被时间复杂为43的确定型机器程序接受。命题2说明了为什么在证明P = NP之前，所有的NPC问题都只有指数算法。",
        "original": "对于非确定型机器的表达式8，构造确定型机器26。如果表达式8有可停机的分支，则26也能找到并停机。因此得出结论。命题2：如果非确定型机器8在多项式时间内接受语言L，则存在P多项式。该多项式使得语言L能被时间复杂度为43的确定型机器程序接受。命题2说明了为什么在证明P = NP之前，所有的NPC问题都只有指数级算法。",
        "version": 2,
        "chunk_num": 3,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "不确定图灵机": "不确定机器",
            "确定图灵机": "确定机器",
            "状态树": "计算树",
            "迭代加深搜索": "迭代加深搜索算法",
            "多项式时间内": "在多项式时间内",
            "时间复杂度": "时间复杂",
            "指数算法": "指数级算法",
            "NPC问题": "NPC问题"
        },
        "simplified_text": "对于任意一个不确定机器，存在一个与之语言相等的确定机器。由于不确定机器的计算过程是计算树，因此理论上只需遍历这棵树就能模拟其计算过程。但直接使用深度优先遍历计算树不可行，因为有些计算分支可能永远不会停止。因此，我们可以使用一种称为迭代加深搜索算法的方法来遍历计算树。关于这种方法的具体证明，请参考以下内容：对于不确定型机器的表达式8，我们构造了确定型机器26。如果表达式8有能停机的分支，则26也能找到并停机。由此，我们得出结论。命题2表明：如果不确定型机器8能在多项式时间内接受语言L，那么存在一个P多项式。这个多项式使得语言L可以被时间复杂度为43的确定型机器程序接受。命题2说明了为什么在证明P=NP之前，所有的NPC问题都只有指数级算法。",
        "original": "对于任意一个不确定图灵机，存在一个与之语言相等的确定图灵机。由于不确定图灵机的计算过程是状态树，因此理论上只需遍历这棵树就能模拟其计算过程。但直接使用深度优先遍历状态树不可行，因为有些计算分支可能永远不会停止。因此，我们可以使用一种称为迭代加深搜索的算法来遍历状态树。关于这种方法的具体证明，请参考以下内容：对于不确定型机器的表达式8，我们构造了确定型机器26。如果表达式8有能停机的分支，则26也能找到并停机。由此，我们得出结论。命题2表明：如果不确定型机器8能在多项式时间内接受语言L，那么存在一个P多项式。这个多项式使得语言L可以被时间复杂度为43的确定型机器程序接受。命题2说明了为什么在证明P = NP之前，所有的NPC问题都只有指数算法。",
        "version": 3,
        "chunk_num": 2,
        "type": "Wiki"
    }
]