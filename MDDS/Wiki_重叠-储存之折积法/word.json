[
    {
        "substitutions": {
            "离散": "分散的",
            "Overlap-save method": "重叠-储存法",
            "Overlap-discard method": "重叠-丢弃法",
            "block convolution": "区块卷积",
            "sectioned convolution": "分段卷积",
            "FIR 滤波器": "有限冲激响应滤波器",
            "h[n]": "滤波器系数",
            "M": "某个长度参数",
            "L": "适当长度",
            "y[n]": "输出信号",
            "x[n]": "输入信号",
            "kL": "某个长度乘以L",
            "formula_4": "公式4",
            "formula_7": "公式7"
        },
        "simplified_text": "重叠-储存法（Overlap-save method，Overlap-discard method）是一种区块卷积（block convolution，sectioned convolution），能有效计算一个很长信号和有限冲激响应滤波器的离散折积。其中滤波器系数在指定长度之外为零。与重叠-相加法不同，这种方法计算的输出区块不重叠，减少了相加步骤，每次读取输入后需要存储重叠部分作为下一区块的开头，所以叫“重叠-储存法”。此外，它也不需要补零。在概念上，我们选择一个较短长度来切割输出信号，因为滤波器长度有限，所以某一区块内的信号只由较长的输入区块决定。我们只需计算有影响的输入区块和滤波器系数的乘积，再选择适当结果即可得到正确的输出区块。对于公式4中的n，输出信号可以表示为n在公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。",
        "original": "重叠-储存之折积法\n重叠-储存之折积法 ( \"Overlap-save method\", \"Overlap-discard method\" ) 是一种区块折积 ( block convolution, sectioned convolution )，可以有效的计算一个很长的信号 \"x\"[\"n\"] 和一个 FIR 滤波器 \"h\"[\"n\"] 的离散折积。\n其中 \"h\"[\"m\"] 在 [1, \"M\"] 之外为零。\n与重叠-相加之折积法不同之处在于，重叠-储存之折积法所算出的输出区块并不重叠 (因此计算上少了将输出区块相加所需的加法)，而是每次用的输入区块有所重叠。因此实作时每次读取输入后需将和下一个输入重叠的部分储存起来，作为下一输入区块的开头部份，因此称为\"重叠\"-\"储存\"之折积法。另外重叠-储存之折积法也不需补零。\n概念上，这个做法是选用一个较短的适当长度 \"L\" 来切割 \"y\"[\"n\"] ，则因为 \"h\"[\"n\"] 是有限长度，因此在某一区块内的 \"y\"[\"n\"] 也只被有限长的 \"x\"[\"n\"] 区块（会比 \"y\"[\"n\"] 分割成的区块长一点）所决定。因此只要选择有影响的输入区块和 \"h\"[\"n\"] 折积，再选择结果中适当的部分即可得到正确的输出区块。\n则对于在 formula_4 内的 \"n\" ， 输出 \"y\"[\"n\"] 可写成\n所以只需计算 \"n\" 在 formula_4 中的 \"y\"[\"n\" + \"M\" - \"kL\"] ，亦即 \"n\" 在 formula_7 的 \"y\"[\"n\"] 部份即可。因此每一段输出区块 \"y\"[\"n\"] 的前 \"M\"-1 点可丢弃（discard）。",
        "version": 1,
        "chunk_num": 1,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "定理": "原则或规律",
            "数量级": "表示大小级别，如10的幂指数"
        },
        "simplified_text": "尽管一时看不出分割成区块的好处，但将 'x[n]' 延伸周期后，'formula_10' 和 'formula_11' 在 'formula_7' 部分相等。因此可以用 'formula_13' 点圆周折积来计算线性折积，输出 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补零。用圆周折积计算后，根据圆周折积定理可以转换成三次 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法，使每段 'O(N)' 的运算量减少到 'O(N log N)'，速度大幅提升。当 'x[n]' 的长度 'N'' 和 'h[n]' 的长度 'M' 差距很大时（例如 'M' < log 'N''），直接折积（不经过圆周折积和 FFT）反而最快。当 'N'' 和 'M' 差不多在同一级别时，不用分割，只需要一个长度 'L' = 'N'' 的区块做 FFT。当 'N'' 比 'M' 大很多，但不是很多时，需要选择区块长度 'L'。除了与 'N'' 和 'M' 相关，还要考虑当两者相除有余数时，剩余一小段输入可能造成浪费。",
        "original": "尽管一时看不出切割成区块的好处为何，但将 \"x\"[\"n\"] 做 formula_8 的周期延伸，\n则 formula_10 和 formula_11 这两个折积在 formula_7 的部份相等。所以可以将线性折积改以 formula_13 点圆周折积计算，结果的 formula_7 部分作为输出 \"y\"[\"n\"] 在 formula_4 的部份。由于每段 \"x\"[\"n\"] 原本就有 formula_16 长，所以选择 formula_17 的话输入 \"x\"[\"n\"] 就不需补零。\n改以圆周折积计算后即可藉圆周折积定理\n转换成三次 formula_13 点快速傅立叶变换和 formula_13 次乘法，使原本每段 \"O\"(\"N\") 的运算量减少至 \"O\"(\"N\" \"logN\")，速度大幅增加。\n (\"Overlap-save algorithm for linear convolution\")\n当 \"x\"[\"n\"] 的长度 \"N' \" 和 \"h\"[\"n\"] 的长度 \"M\" 相差太大时（例如 \"M\" < log\"N' \" ），直接折积（不透过圆周折积和 FFT ）反而最快。而当 \"N' \" 和 \"M\" 差不多在同一个数量级时，不用分割，也就是只有一块长度 \"L\" = \"N' \" 的区块去做 FFT 即可。而当 \"N' \" 比 \"M\" 大了不少，却没大太多时，区块长度 \"L\" 就需要选择。除了与 \"N' \" 和 \"M\" 相关以外，也要考虑当两者相除有余数时，剩下一小段的输入可能会造成浪费。",
        "version": 1,
        "chunk_num": 2,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "重叠-储存法": "Overlap-save method",
            "Overlap-discard method": "Overlap-discard method",
            "区块卷积": "区块卷积",
            "离散折积": "离散折积",
            "有限冲激响应滤波器": "有限冲激响应滤波器",
            "重叠-相加法": "Overlap-add method",
            "重叠部分": "重叠部分",
            "补零": "补零",
            "区块": "区块",
            "冲激": "冲撞"
        },
        "simplified_text": "Overlap-save method，也称为Overlap-discard method，是一种区块卷积，能有效计算长信号和有限冲激响应滤波器的离散折积。滤波器系数在指定长度外为零。与Overlap-add method不同，这种方法输出区块不重叠，减少了相加步骤。每次读取输入后，需要存储(存款和储蓄)重叠部分作为下一区块的开头，因此称为“重叠-储存法”。此外，它也不需要补零。我们选择较短长度来切割输出信号，因为滤波器长度有限，某一区块信号仅由较长的输入区块决定。计算有影响的输入区块与滤波器系数的乘积，选取适当结果即可得到正确的输出区块。对于公式4中的n，输出信号可以表示为公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。",
        "original": "重叠-储存法，又称Overlap-save method或Overlap-discard method，是一种区块卷积，能够有效计算长信号与有限冲激响应滤波器的离散折积。其中滤波器系数在指定长度之外为零。与重叠-相加法不同，该方法输出区块不重叠，减少相加步骤。每次读取输入后，需存储重叠部分作下一区块开头，故称“重叠-储存法”。此外，它也不需要补零。我们选择较短长度切割输出信号，因滤波器长度有限，某一区块信号仅由较长的输入区块决定。计算有影响的输入区块与滤波器系数的乘积，选取适当结果即得正确输出区块。对于公式4中的n，输出信号可以表示为n在公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。",
        "version": 2,
        "chunk_num": 1,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "显著": "非常明显",
            "圆周": "圆形轨迹"
        },
        "simplified_text": "虽然一时看不出将 'x[n]' 延伸周期的好处，但 'formula_10' 和 'formula_11' 在 'formula_7' 部分相等。因此可以用 'formula_13' 的圆形轨迹折积来计算线性折积，输出 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。通过圆形轨迹折积计算和定理转换，每段运算量从 'O(N)' 降低到 'O(N log N)'，实现 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法，速度非常明显提升。当 'x[n]' 的长度 'N' 和 'h[n]' 的长度 'M' 差距很大，尤其是 'M' 小于 'N' 的对数时，直接折积（无需圆形轨迹折积和 FFT）会更加快速。当 'N' 和 'M' 同级时，无需分割。只需用长度为 'N' 的一个区块进行 FFT。当 'N' 比 'M' 大很多，但不是很多时，需要选择区块长度 'L'。除了与 'N' 和 'M' 相关，还要考虑当两者相除有余数时，剩余一小段输入可能造成浪费。",
        "original": "虽然一时看不出将 'x[n]' 延伸周期的好处，但 'formula_10' 和 'formula_11' 在 'formula_7' 部分相等。因此可以用 'formula_13' 点圆周折积来计算线性折积，输出 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。通过圆周折积计算和定理转换，每段运算量从 'O(N)' 降低到 'O(N log N)'，实现 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法，速度显著提升。当 'x[n]' 的长度 'N' 和 'h[n]' 的长度 'M' 差距很大，尤其是 'M' 小于 'N' 的对数时，直接折积（无需圆周折积和 FFT）会更加快速。当 'N' 和 'M' 同级时，无需分割。只需用长度为 'N' 的一个区块进行 FFT。当 'N' 比 'M' 大很多，但不是很多时，需要选择区块长度 'L'。除了与 'N' 和 'M' 相关，还要考虑当两者相除有余数时，剩余一小段输入可能造成浪费。",
        "version": 2,
        "chunk_num": 2,
        "type": "Wiki"
    },
    {
        "substitutions": {
            "Overlap-save method": "重叠存储法",
            "Overlap-discard method": "重叠丢弃法",
            "区块卷积": "区块卷积",
            "离散折积": "离散卷积",
            "滤波器": "滤波器",
            "相加步骤": "加法步骤",
            "重叠-储存法": "重叠存储法",
            "补零": "补零",
            "输出信号": "输出信号",
            "滤波器长度": "滤波器长度",
            "乘积": "乘积",
            "适当的": "合适的",
            "丢弃": "丢弃",
            "x[n]": "信号x",
            "formula_10": "公式10",
            "formula_11": "公式11",
            "formula_7": "公式7",
            "y[n]": "信号y",
            "formula_4": "公式4",
            "formula_13": "公式13",
            "圆形轨迹折积": "圆周卷积",
            "线性折积": "线性卷积",
            "运算量": "运算量",
            "O(N)": "O(N)",
            "O(N log N)": "O(N log N)",
            "快速傅立叶变换": "快速傅立叶变换",
            "次乘法": "乘法运算",
            "系数": "常数"
        },
        "simplified_text": "重叠存储(存款和储蓄)法，也称作重叠丢弃法，是一种区块卷积。它能够高效计算长信号与有限冲激响应滤波器的离散卷积。滤波器系数在指定长度外为零。与重叠加法法不同，重叠存储(存款和储蓄)法输出区块不重叠，减少了加法步骤。读取输入后，存储(存款和储蓄)相同的部分作为下一区块的起始，这种方法称为‘重叠-存储(存款和储蓄)法’。此外，它也不需要补零。输出信号使用较短长度切割，因为滤波器长度有限，信号区块由较长输入区块决定。计算输入区块与滤波器常数的乘积，选取合适的结果得到正确的输出区块。对于公式4中的n，输出信号可以表示为公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。虽然看不出将 'x[n]' 延伸周期的益处，但 'formula_10' 和 'formula_11' 在 'formula_7' 的部分是相等的。因此，可以用 'formula_13' 的圆周卷积来计算线性卷积，从而得到 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。通过圆周卷积计算和定理转换，运算量从 'O(N)' 降低到 'O(N log N)'，这显著提升了 'formula_13' 点快速傅立叶变换和乘法运算的速度。",
        "original": "Overlap-save method，又称Overlap-discard method，是一种区块卷积。它能有效计算长信号与有限冲激响应滤波器的离散折积。滤波器系数在指定长度外为零。\n与Overlap-add method不同，Overlap-save method输出区块不重叠，减少了相加步骤。读取输入后，存储存款和储蓄的相同部分作为下一区块的起始，这方法叫做‘重叠-储存法’。此外，它也不需要补零。\n输出信号采用较短长度切割，因滤波器长度有限，信号区块由较长输入区块决定。计算输入区块与滤波器系数的乘积，选取适当结果便得到正确的输出区块。\n对于公式4中的n，输出信号可以表示为公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。\n虽然看不出将 'x[n]' 延伸周期的益处，但 'formula_10' 和 'formula_11' 在 'formula_7' 的部分是相等的。因此，可以用 'formula_13' 的圆形轨迹折积来计算线性折积，从而得到 'y[n]' 在 'formula_4' 的部分。\n因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。通过圆形轨迹折积计算和定理转换，运算量从 'O(N)' 降低到 'O(N log N)'，这显著提升了 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法的速度。",
        "version": 3,
        "chunk_num": 1,
        "type": "Wiki"
    }
]