[
    {
        "simp_type": [
            "拆分"
        ],
        "simplified_text": "Overlap-save method，又称Overlap-discard method，是一种区块卷积。它能有效计算长信号与有限冲激响应滤波器的离散折积。滤波器系数在指定长度外为零。\n\n 与Overlap-add method不同，Overlap-save method输出区块不重叠，减少了相加步骤。读取输入后，存储存款和储蓄的相同部分作为下一区块的起始，这方法叫做‘重叠-储存法’。此外，它也不需要补零。\n\n 输出信号采用较短长度切割，因滤波器长度有限，信号区块由较长输入区块决定。计算输入区块与滤波器系数的乘积，选取适当结果便得到正确的输出区块。\n\n 对于公式4中的n，输出信号可以表示为公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。",
        "original": "Overlap-save method，又称Overlap-discard method，是一种区块卷积。它能有效计算长信号与有限冲激响应滤波器的离散折积。滤波器系数在指定长度外为零。与Overlap-add method不同，这种方法输出区块不重叠，减少了相加步骤。读取输入后，存储存款和储蓄的相同部分作为下一区块的起始，这方法叫做‘重叠-储存法’。此外，它也不需要补零。输出信号采用较短长度切割，因滤波器长度有限，信号区块由较长输入区块决定。计算输入区块与滤波器系数的乘积，选取适当结果便得到正确的输出区块。对于公式4中的n，输出信号可以表示为公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。",
        "version": 2,
        "chunk_num": 1,
        "type": "Wiki"
    },
    {
        "simp_type": [
            "拆分",
            "添加过渡"
        ],
        "simplified_text": "虽然看不出将 'x[n]' 延伸周期的益处，但 'formula_10' 和 'formula_11' 在 'formula_7' 的部分是相等的。因此，可以用 'formula_13' 的圆形轨迹折积来计算线性折积，从而得到 'y[n]' 在 'formula_4' 的部分。\n\n因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。通过圆形轨迹折积计算和定理转换，运算量从 'O(N)' 降低到 'O(N log N)'，这显著提升了 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法的速度。\n\n当 'x[n]' 的长度 N 与 'h[n]' 的长度 M 差距较大，尤其是 M 小于 N 的对数时，直接进行折积（无需圆形轨迹折积和 FFT）会更快速。当 N 和 M 同级时，无需分割。只需使用长度为 N 的一个区块进行 FFT。当 N 比 M 大很多，但不是很多时，需要选择区块长度 'L'。在决定 'L' 时，除了与 N 和 M 相关，还需考虑当两者相除有余数时，剩余一小段输入可能造成浪费。",
        "original": "虽然看不出将 'x[n]' 延伸周期的益处，但 'formula_10' 和 'formula_11' 在 'formula_7' 的部分是相等的。因此可以用 'formula_13' 的圆形轨迹折积来计算线性折积，输出 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。通过圆形轨迹折积计算和定理转换，运算量从 'O(N)' 降低到 'O(N log N)'。这使得 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法的速度明显提升。当x[n]的长度N与h[n]的长度M差距较大，特别是M小于N的对数时，直接进行折积（无需圆形轨迹折积和FFT）会更快速。当 'N' 和 'M' 同级时，无需分割。只需用长度为 'N' 的一个区块进行 FFT。当 'N' 比 'M' 大很多，但不是很多时，需要选择区块长度 'L'。除了与 'N' 和 'M' 相关，还要考虑当两者相除有余数时，剩余一小段输入可能造成浪费。",
        "version": 2,
        "chunk_num": 2,
        "type": "Wiki"
    },
    {
        "simp_type": [
            "冗余删除",
            "添加标题"
        ],
        "simplified_text": "## 重叠存储法简介\n\n重叠存储法，又称重叠丢弃法，是一种区块卷积技术。它能高效计算长信号与有限冲激响应滤波器的离散卷积，滤波器系数在指定长度外为零。与重叠加法不同，重叠存储法输出区块不重叠，减少了加法步骤。读取输入后，存储相同的部分作为下一区块起始。此方法无需补零，输出信号切割较短，信号区块长度由输入区块决定。通过计算输入区块与滤波器常数的乘积，选择合适的结果得到正确的输出区块。输出信号的前几个点可丢弃。虽然无法直接看出延伸周期的好处，但某些部分可以使用圆周卷积来计算线性卷积，得到正确结果。因为输入信号本身已足够长，所以输入不需要补充零。",
        "original": "重叠存储(存款和储蓄)法，也称作重叠丢弃法，是一种区块卷积。它能够高效计算长信号与有限冲激响应滤波器的离散卷积。滤波器系数在指定长度外为零。与重叠加法法不同，重叠存储(存款和储蓄)法输出区块不重叠，减少了加法步骤。读取输入后，将存款和储蓄相同的部分存储为下一区块的起始。这种方法叫做‘重叠-存储(存款和储蓄)法’。此外，它也不需要补零。输出信号切割较短，因滤波器长度有限，信号区块长度由输入区块决定。计算输入区块与滤波器常数的乘积，选取合适的结果得到正确的输出区块。对于公式4中的n，输出信号可以表示为公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。虽然看不出延伸 'x[n]' 周期的好处，但 'formula_10' 和 'formula_11' 在 'formula_7' 的某些部分是相等的。因此，可以用 'formula_13' 的圆周卷积来计算线性卷积，从而得到 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补充零。",
        "version": 3,
        "chunk_num": 1,
        "type": "Wiki"
    },
    {
        "simp_type": [
            "冗余删除",
            "添加标题"
        ],
        "simplified_text": "## 快速傅立叶变换优化\n\n通过圆周卷积和定理转换，运算量从'O(N)'降低到'O(N log N)'，显著提升了'formula_13'点快速傅立叶变换和乘法运算的速度。当'x[n]'的长度N与'h[n]'的长度M差距较大时，直接折积（无需圆形轨迹折积和FFT）更快速。当 N 和 M 同级时，无需分割。当 N 比 M 大很多时，需选择合适的区块长度 'L'，同时考虑余数导致的输入浪费。",
        "original": "通过圆周卷积和定理转换，运算量从'O(N)'降低到'O(N log N)'，从而显著提升了'formula_13'点快速傅立叶变换和乘法运算的速度。当'x[n]'的长度N与'h[n]'的长度M差距较大，尤其是M小于N的对数时，直接折积（无需圆形轨迹折积和FFT）更快速。当 N 和 M 同级时，无需分割。只需使用长度为 N 的一个区块进行 FFT。当 N 比 M 大很多，但不是很多时，需要选择区块长度 'L'。在决定 'L' 时，除了与 N 和 M 相关，还需考虑当两者相除有余数时，剩余一小段输入可能造成浪费。",
        "version": 3,
        "chunk_num": 2,
        "type": "Wiki"
    }
]