重叠-储存法（Overlap-save method，Overlap-discard method）是一种区块卷积（block convolution，sectioned convolution），能有效计算一个很长信号和有限冲激响应滤波器的离散折积。其中滤波器系数在指定长度之外为零。与重叠-相加法不同，这种方法计算的输出区块不重叠，减少了相加步骤，每次读取输入后需要存储重叠部分作为下一区块的开头，所以叫“重叠-储存法”。此外，它也不需要补零。在概念上，我们选择一个较短长度来切割输出信号，因为滤波器长度有限，所以某一区块内的信号只由较长的输入区块决定。我们只需计算有影响的输入区块和滤波器系数的乘积，再选择适当结果即可得到正确的输出区块。对于公式4中的n，输出信号可以表示为n在公式7的y[n]部分。因此，每段输出区块的前几个点可以丢弃。

尽管一时看不出分割成区块的好处，但将 'x[n]' 延伸周期后，'formula_10' 和 'formula_11' 在 'formula_7' 部分相等。因此可以用 'formula_13' 点圆周折积来计算线性折积，输出 'y[n]' 在 'formula_4' 的部分。因为每段 'x[n]' 本身就足够长，所以选择 'formula_17' 时，输入 'x[n]' 就不需要补零。用圆周折积计算后，根据圆周折积定理可以转换成三次 'formula_13' 点快速傅立叶变换和 'formula_13' 次乘法，使每段 'O(N)' 的运算量减少到 'O(N log N)'，速度大幅提升。当 'x[n]' 的长度 'N'' 和 'h[n]' 的长度 'M' 差距很大时（例如 'M' < log 'N''），直接折积（不经过圆周折积和 FFT）反而最快。当 'N'' 和 'M' 差不多在同一级别时，不用分割，只需要一个长度 'L' = 'N'' 的区块做 FFT。当 'N'' 比 'M' 大很多，但不是很多时，需要选择区块长度 'L'。除了与 'N'' 和 'M' 相关，还要考虑当两者相除有余数时，剩余一小段输入可能造成浪费。

